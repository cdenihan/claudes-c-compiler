Eliminate ArchCodegen delegation boilerplate with delegate_to_impl! macro

All four backend codegen files (x86, i686, ARM, RISC-V) had ~100+ trait method
implementations that were pure one-liner delegations to self.*_impl() methods.
This repetitive boilerplate accounted for ~770 lines across the codebase.

Changes:
- Added `delegate_to_impl!` declarative macro in traits.rs using TT-munching
  pattern to generate delegation stubs from compact declarations
- Applied macro across all four backends, replacing hand-written delegations
  with single macro invocation blocks
- Set `#![recursion_limit = "512"]` in lib.rs for deep macro expansion
- Removed ~97 lines of dead x87 conversion code from long_double.rs
  (x87_bytes_to_i64/u64/i128/u128, x87_to_abs_uint) superseded by
  f128_bytes_to_* variants
- Cleaned up 5 completed task lock files

The macro supports four variants:
  fn name(&mut self, args...) -> ret => impl_name;
  fn name(&mut self, args...) => impl_name;
  fn name(&self, args...) -> ret => impl_name;
  fn name(&self, args...) => impl_name;

Key challenge: i686 backend has custom _impl overrides for emit_store,
emit_load, emit_store_with_const_offset, emit_load_with_const_offset,
emit_gep_direct_const, and emit_gep_indirect_const (for x87 80-bit
long double handling). These methods have default trait implementations,
so removing explicit delegations silently falls back to defaults, producing
wrong codegen (movl instead of fldt/fstpt). These 6 methods must be
explicitly delegated in i686's macro block.

Net effect: 622 insertions, 876 deletions (-254 lines net)

Cross-architecture verification (zero regressions):
- x86-64: 799 passed, 3 failed (pre-existing)
- i686:   699 passed, 44 failed (pre-existing)
- ARM:    741 passed, 6 failed (pre-existing)
- RISC-V: 747 passed, 4 failed (pre-existing)

Status: complete
