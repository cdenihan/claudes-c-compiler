Fix compound literal values in global struct initializers

Problem:
When a compound literal is used as a non-pointer struct field initializer in
a global variable declaration, the value is incorrectly zeroed out.

Example:
  typedef struct { unsigned long bits[1]; } mask_t;
  typedef struct { int x; mask_t m; } outer_t;
  outer_t t = { .x = 1, .m = (mask_t){ { 0xFFFFFFFFFFFFFFFFUL } } };

The field t.m is incorrectly initialized to zero instead of 0xFFFFFFFFFFFFFFFF.
Direct (non-compound) initialization works fine:
  outer_t t = { .x = 1, .m = { { 0xFFFFFFFFFFFFFFFFUL } } };

Root cause:
In lower_global_init (global_init.rs), compound literals are only handled
for the IrType::Ptr case (creating anonymous globals). Non-pointer compound
literals fall through to the "Can't evaluate" fallback, producing GlobalInit::Zero.

Fix:
When a compound literal expression is encountered in a global initializer
and the target type is NOT a pointer, recursively lower the compound literal's
inner initializer using the compound literal's type information.

Impact:
- Fixes init/init_task.c boot failure (cpus_mask = CPU_MASK_ALL uses compound literal)
- Fixes multiple other kernel boot failures related to compound literal initialization
- Affects all architectures (x86, arm, riscv)
