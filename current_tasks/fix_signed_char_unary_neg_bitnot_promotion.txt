Task: Fix missing integer promotion (sign-extension) for sub-int types in unary Neg and BitNot
Status: in_progress
Started: 2026-01-26

Bug: When computing unary negation (-x) or bitwise not (~x) on signed char or
short values, the lowering performs the operation in I64 without first
sign-extending the sub-int value. This causes signed char -13 (0xF3) to be
zero-extended to 243, then negated to -243 instead of the correct 13.

Same issue for BitNot: ~(signed char -13) gives -244 instead of 12.

Root cause: In lower_unary_op() for Neg and BitNot cases, lower_expr(inner)
returns the raw I8/I16 value, but the operation is performed in I64 without
a widening cast. The backend loads the I8/I16 value, leaving upper bits as
zero (zero-extension), then negates/complements in I64.

Fix: Before emitting the Neg/BitNot instruction, emit a Cast from inner_ty
to I64 using the correct signedness of inner_ty. This ensures sign-extension
for signed types (I8, I16) and zero-extension for unsigned types (U8, U16).

Affects all three architectures (x86, ARM, RISC-V) since the bug is in the
frontend/IR lowering, not in backend codegen.
