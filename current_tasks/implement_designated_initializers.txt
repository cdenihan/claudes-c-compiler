Task: Implement designated initializer support
Status: Completed

Problem:
- Designated initializers (.field = val for structs, [idx] = val for arrays) were parsed
  into the AST (Designator::Field, Designator::Index) but ignored during IR lowering
- Global struct initializers (lower_struct_global_init) iterated items sequentially,
  ignoring .field designators, so {.b = 2, .a = 1} assigned wrong values
- Local struct initializers in stmt.rs iterated by enumerate index, not by designator
- Array designated initializers ([2] = 5) were not supported in either local or global context
- Compound literals with struct type didn't handle designators either
- &(compound_literal) generated an "unknown" symbol reference
- Octal lexer failed on float literals like -000.001
- Tentative definitions (extern followed by non-extern) not properly emitted

Fix Applied:
- In lower_struct_global_init: look up field index from designator name in struct layout
- In local struct init (stmt.rs): same - use designator to determine field target
- In array init: use designator index to determine target element position
- Zero-initialize first, then fill designated positions
- Support mixed designated/positional initializers (positional continues from last position)
- Fixed &(compound_literal) to return alloca directly
- Fixed compound literal struct/array init to use designators
- Fixed octal lexer to detect float after 0-prefix digits
- Fixed tentative definition emission for extern + non-extern patterns
- Added compute_init_list_array_size for unsized array determination

Remaining limitations (not regressions):
- Nested struct designators (.cfg = {.w=1, .h=2}) not yet supported
- Chained designators (.fields[0] = val) not yet supported
- Compound literal struct assignment to struct variable needs struct copy (locked)
