Fix pointer arithmetic stride on union members accessed through forward-declared union pointers.

Bug: When a forward-declared union (e.g., GCObject) had a member (e.g., TString) accessed
via pointer arithmetic like (&obj->ts + 1), the compiler used the wrong stride (8 instead
of 24). This happened because:

1. The AddressOf handler in get_pointer_elem_size_from_expr used get_expr_type(inner).size()
   which returns IrType::Ptr.size() = 8 for all struct/union types (since they map to Ptr
   in the IR), instead of the actual sizeof the union.

2. resolve_ctype_size short-circuited on sz > 0 without checking the authoritative
   struct_layouts HashMap, so stale cached sizes in CType objects were trusted.

Fix:
- AddressOf case now uses sizeof_expr(inner) which correctly resolves struct/union sizes.
- resolve_ctype_size now always prefers struct_layouts for tagged types (the authoritative
  source) over the possibly-stale cached_size in CType objects.

Impact: Fixes Redis server startup (Lua initialization crash from wrong string pointer).
