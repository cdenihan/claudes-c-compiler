Task: Fix pointer arithmetic sign extension for int operands

Bug: When adding a signed 32-bit int to a pointer (e.g., ptr + (int)val),
the compiler zero-extends the int to 64-bit instead of sign-extending.
This causes negative offsets to become large positive offsets.

Example:
  uint8_t *pc = ...;
  uint32_t val = 0xFFFFFFF9; // -7 when cast to int
  uint8_t *new_pc = pc + (int)val;
  // GCC: correctly produces pc - 7
  // CCC: incorrectly produces pc + 4294967289

Impact: Causes SIGSEGV in mquickjs regexp engine (lre_exec) which uses
pc + (int)val for relative bytecode jumps, including backward jumps.

Root cause: The IR lowering or codegen for pointer+int addition doesn't
properly sign-extend 32-bit int operands to 64-bit before the addition.

Status: in progress
