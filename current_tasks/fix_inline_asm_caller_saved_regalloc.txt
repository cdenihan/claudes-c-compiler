Task: Enable caller-saved register allocation for functions with inline asm

Status: in_progress

Problem: Functions containing inline assembly have ALL caller-saved registers
(r8-r11 on x86) disabled for register allocation. This forces nearly every
SSA value onto the stack, creating massive stack frames (2640+ bytes for
functions like kernel's rmqueue). The Linux kernel has a stack limit that
triggers a stack overflow panic during PCI enumeration at boot time.

Root cause: In liveness.rs, InlineAsm instructions are not treated as
call_points, so the register allocator doesn't know that inline asm can
clobber caller-saved registers. The workaround in codegen.rs (line 1473-1475)
disables ALL caller-saved regs for the entire function when any inline asm
is present, which is overly conservative.

Fix: Add InlineAsm to the call_points in liveness.rs (same as Call/CallIndirect),
then remove the blanket caller-saved register disable in codegen.rs for all
backends. This way:
1. Values live across inline asm won't get caller-saved regs (safe)
2. Values NOT live across inline asm CAN use caller-saved regs (saves stack)
3. Stack frames will shrink dramatically for kernel functions

Impact: Fixes x86 defconfig kernel boot (stack overflow in rmqueue/slub path).
