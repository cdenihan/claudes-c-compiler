Narrow pass: allow AShr narrowing for signed types

Status: in_progress

Problem:
The narrowing pass in src/passes/narrow.rs currently excludes AShr and LShr
from the set of operations that can be narrowed (lines 192-199). This means
the widen-shift-narrow pattern:
  %w = Cast %x, I32 -> I64
  %r = BinOp AShr %w, 16, I64
  %n = Cast %r, I64 -> I32
Cannot be simplified to:
  %r = BinOp AShr %x, 16, I32

This pattern appears frequently in DOOM's rendering code, where fixed-point
arithmetic uses (frac >> FRACBITS) & 0x7f for texture indexing. Each such
pattern generates an unnecessary i32->i64 cast and i64->i32 truncation.

Analysis:
- AShr narrowing from I64->I32 IS safe when the widened operand was originally
  I32 (sign-extended). Sign extension preserves the sign bit, and AShr propagates
  it, so the lower 32 bits of the I64 AShr result match the I32 AShr result.
- LShr narrowing IS safe for unsigned types (U32->U64 zero-extends, and LShr
  on the zero-extended value gives the same lower 32 bits as LShr on the original).
- LShr narrowing is NOT safe for signed types because sign extension sets the upper
  32 bits, and LShr would shift those bits down.

Implementation:
1. Add AShr to the safe_to_narrow list for signed types
2. Add LShr to the safe_to_narrow list for unsigned types
3. Add test cases
4. Measure impact on DOOM binary code size

Expected impact:
- Eliminates unnecessary cltq/movslq pairs around shift operations
- Reduces both code size and runtime overhead for fixed-point arithmetic patterns
