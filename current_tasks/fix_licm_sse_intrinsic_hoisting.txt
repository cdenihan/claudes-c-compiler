Task: Fix LICM incorrectly hoisting SSE intrinsic instructions that read from loop-modified allocas

Problem: The LICM pass classified SSE intrinsic instructions (Pshufd128, etc.) as "pure"
and hoisted them out of loops when their pointer arguments were loop-invariant. However,
these intrinsics read from memory through their alloca pointer arguments, and the memory
contents change across loop iterations (written by memcpy/store inside the loop body).

The LICM alloca analysis (analyze_allocas) only collected allocas from the entry block
(blocks[0]), but after function inlining, callee entry-block allocas can appear in
non-entry blocks of the caller. These non-entry-block allocas were invisible to the
LICM safety check, causing the intrinsic-specific guard to fail to block hoisting.

Additionally, finalize_function used rposition to find the last Alloca in the entry block
when splicing deferred entry allocas. With inline SSE result allocas scattered throughout
the block, this could place deferred allocas after their uses.

Fix:
1. Changed analyze_allocas() in licm.rs to collect allocas from ALL blocks, not just blocks[0]
2. Changed finalize_function() in func_lowering.rs to use position() (first non-Alloca)
   instead of rposition() (last Alloca) for insertion point

Also added missing SSE intrinsics: _mm_mul_epu32, _mm_set_epi64x, _mm_prefetch,
_mm_malloc, _mm_free

This fixes xxhash (x86/arm/riscv) and also fixes mbedtls on x86 (was a regression).

Status: completed

Test Results:
- 10% sample: x86 2986/2990 (99.9%), ARM 2849/2868 (99.3%), RISC-V 2857/2859 (99.9%), i686 2735/2737 (99.9%)
- All 12 core projects pass on x86/ARM/RISC-V (47/48 pass overall, only mbedtls i686 pre-existing fail)
- xxhash: pass on x86/arm/riscv (i686 pre-existing 64-bit hash issue)
- mbedtls x86: FIXED (was failing before, now passes)
- brotli: pass on all 4 architectures
