Task: Fix function pointer parameter name shadowing builtin function signatures
Status: in_progress

Problem:
When a function pointer parameter has the same name as a known/seeded library
function (e.g., `round`, `ceil`, `floor`, `sin`, etc.), the compiler uses the
library function's signature instead of the function pointer's actual signature
for argument type coercion and return type resolution.

This causes:
1. Arguments to be implicitly cast to the wrong types (e.g., void* -> double)
2. Return values to be treated as the wrong type (e.g., double instead of ulong)
3. On RISC-V without D extension (-march=rv64imac), this generates invalid FP
   instructions (fcvt.d.l, fmv.d.x, etc.) that the assembler rejects

Example triggering code (from Linux kernel drivers/clk/sunxi-ng/ccu_mux.c):
  int ccu_mux_helper_determine_rate(...,
      unsigned long (*round)(struct ccu_mux_internal *, ...)) {
      best_rate = round(cm, parent, ...);  // <-- 'round' resolves to math round()
  }

Root cause: In lower_call_arguments() and get_call_return_type(), the lookup
order is sigs (global function signatures) first, then ptr_sigs (function
pointer signatures). When a parameter named 'round' exists, sigs["round"]
returns the seeded double->double signature, and the ptr_sigs entry with
the correct ulong->ulong signature is never checked.

Fix: When the name refers to a local function pointer variable, prefer
ptr_sigs over sigs for signature lookup.
