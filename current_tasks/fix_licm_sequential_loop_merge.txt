Fix LICM miscompilation: sequential loops incorrectly merged into one giant loop

Bug: When CFG simplification merges exit/init blocks between sequential for-loops
that share the same iteration bounds, the loops can end up sharing a header block.
merge_loops_by_header() then unions their bodies into one massive "loop" spanning
all sequential loops. LICM finds the function entry as the preheader for this
merged loop and hoists loads of global variables to before they are initialized.

Example: scr2b[0] loaded before loop 1 initializes scr2b, causing the condition
in loop 4 (if scr2b[0] > 0) to evaluate false and skip the entire loop body.

Fix: Add a dominance check in LICM's preheader validation to reject preheaders
that don't properly dominate just the actual loop iteration. Alternatively, limit
global load hoisting to only hoist from loops whose preheader is close to the
header (i.e., the preheader must be an immediate predecessor of the header that
is not part of another loop's structure).

Status: in_progress
Started: 2026-01-30
