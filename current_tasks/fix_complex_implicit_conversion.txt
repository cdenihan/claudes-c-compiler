Fix implicit complex-to-complex type conversions

BUG: When assigning a complex value of one precision to a complex variable of another
precision (e.g., _Complex float -> _Complex double), only the real part is converted.
The imaginary part is lost (zero or garbage).

Root cause: In lower_local_decl() (stmt.rs), complex variable initialization just does
a Memcpy from the expression result without converting between complex types.
Similarly, function return statements and some arithmetic paths may have this issue.

The fix needs to:
1. In declaration initialization: detect when RHS complex type differs from LHS complex
   type and call convert_to_complex() before the memcpy.
2. In return statements: detect when the return expression type differs from the function
   return type and insert conversion.
3. In function call argument passing: ensure complex arguments are converted to the
   parameter type before being passed.
4. In implicit conversion paths (like compound assignment, ternary operator, etc.)

This fix should resolve hundreds of test failures since ~800 of the 876 x86 failures
are related to complex number operations.
