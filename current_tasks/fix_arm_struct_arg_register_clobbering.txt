Task: Fix ARM struct argument register clobbering when arguments are reordered
Status: in_progress

Bug: When calling a function with struct arguments in a different order than
received (e.g., swap_call(x, y) { return check(y, x); }), the ARM codegen
uses x0 as a temporary for address computation after x0 was already loaded
with call argument data, clobbering it.

Example: swap_call receives structs in x0-x1 (first struct) and x2-x3 (second struct).
To call check(y, x), it needs to swap them. The generated code:
  1. Stores args to stack
  2. Loads y from stack into x0,x1 (correct)
  3. Uses "add x0, sp, #16" to compute address of x (OVERWRITES x0!)
  4. Loads x from stack into x2,x3

The bug is that step 3 uses x0 for the address computation, destroying the
value loaded in step 2. It should use a scratch register (x16/x17) instead.

This is an ARM-specific codegen bug in the struct argument loading path.

Fix: In the ARM codegen's function call argument setup, when loading struct
members from memory into argument registers, use a dedicated scratch register
(x16 or x17) for address computation instead of the target register.
