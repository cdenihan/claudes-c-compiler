Fix 128-bit integer ABI and operations (3 bugs causing mbedtls RSA selftest infinite loop)

Root cause: mbedtls RSA selftest was stuck in an infinite loop in mod_mpi's
correction loop because 128-bit integer division (via mbedtls_int_div_int)
produced wildly incorrect results. Three separate bugs were responsible:

Bug 1 - maybe_narrow_call_result incorrectly narrows I128 return values:
  File: src/ir/lowering/expr.rs (maybe_narrow_call_result)
  The function was casting I128/U128 return values from I64 back to I128,
  which inserted a cqto instruction that sign-extended rax into rdx,
  destroying the high 64 bits of the 128-bit return value.
  Fix: Exclude I128/U128 from the narrowing condition.

Bug 2 - 128-bit argument register assignment clobbers rdx:
  File: src/backend/x86/codegen/codegen.rs (128-bit arg emission)
  When the second 128-bit argument targets rdx:rcx, the code did:
    movq %rax, %rdx; movq %rdx, %rcx
  The first move overwrites rdx (which holds the high half) before the
  second move reads it.
  Fix: When target low register is rdx, reverse the move order.

Bug 3 - usual_arithmetic_conversions forces I64 for all integer ops:
  File: src/ir/lowering/expr.rs (usual_arithmetic_conversions)
  The operation type was always set to I64 for integer binary operations,
  even when common_ty was I128/U128. This caused compound assignment |=
  on 128-bit values to only operate on the low 64 bits.
  Fix: Preserve I128/U128 as the operation type when common_ty is 128-bit.

After fix: mbedtls RSA key validation, encryption, and decryption all pass.
The signing test failure is a separate pre-existing issue.
