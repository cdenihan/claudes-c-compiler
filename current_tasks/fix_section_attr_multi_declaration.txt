Fix section attribute not propagated to subsequent declarators in multi-variable declarations

Bug: In a declaration like `__attribute__((section(".mydata"))) static int a, b;`,
only the first variable `a` gets placed in the custom section. The second variable `b`
(and any subsequent) falls through to the default section (.bss or .data).

Root cause: In declarations.rs parse_declaration_rest(), the section attribute from
self.parsing_section is consumed via .take() for the first declarator. When parsing
additional declarators after the comma, self.parsing_section.take() returns None since
it was already consumed. The fix is to fall back to the declaration-level section
attribute when no per-declarator section is present.

Impact: Kernel variables with __meminitdata, __initdata, __cpudata etc. that are declared
as comma-separated lists (e.g., `static long __meminitdata addr_start, addr_end;`) have
the second+ variable placed in .bss instead of the correct section. This could cause
crashes when the kernel frees init memory.

Fix: In the comma-separated declarator loop, use .or_else(|| section.clone()) to inherit
the declaration-level section attribute.

Status: Fix applied, testing in progress
