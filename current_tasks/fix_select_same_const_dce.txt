Fix: constant_fold pass doesn't fold Select(cond, x, y) when both x and y resolve to the same constant.

This causes dead code (e.g., calls inside `if(test_large && always_false)`) to not be eliminated after
if-conversion converts the conditional branch into a Select instruction. Both arms are 0 (one from the
inlined always_false, one from the && default), but one arm is a Value (from cmp ne 0, 0) rather than
an immediate Const(0), so the simplify pass's `same_operand` check fails.

The fix adds constant resolution in the Select folding in the constant_fold pass: if both arms resolve
to the same constant through the const_map, fold to that constant.

This fixes the kernel mm/vmscan.c miscompilation (undefined ref to folio_undo_large_rmappable).
