Fix: unsigned 32-bit constant expression results sign-extended instead of zero-extended to 64-bit

Problem:
When constant-folding expressions like `(2147483647 * 2U + 1U)`, the result is correctly
computed as unsigned 32-bit value 4294967295 (0xFFFFFFFF), but when this value is widened
to 64-bit for assignment to `unsigned long long`, it gets sign-extended to 0xFFFFFFFFFFFFFFFF
instead of zero-extended to 0x00000000FFFFFFFF.

This affects system header definitions of UINT_MAX which expand to `(2147483647 * 2U + 1U)`.

Root cause:
1. eval_const_binop_int() in const_arith.rs always returns IrConst::I32 for 32-bit results,
   even when the operation is unsigned. IrConst::I32 cannot correctly represent unsigned
   values >= 2^31.
2. eval_const_expr_from_parts() in const_eval.rs converts IrConst::I32(v) -> IrConst::I64(v as i64)
   which sign-extends, losing the unsigned semantics.

Fix:
- For unsigned 32-bit results, return IrConst::I64(result as u32 as i64) to preserve zero-extension
- Make eval_const_expr_from_parts aware of expression unsigned-ness when widening
- Apply same fix in sema const_eval path

Affected tests:
- compiler_suite_0113_0110 (K&R function + unsigned overflow semantics)
- Potentially many UINT_MAX-related expressions across the test suite
