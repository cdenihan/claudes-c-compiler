Improve register allocator cost-benefit heuristic to reduce stack frame bloat

Problem: The register allocator assigns callee-saved registers to very short-lived
intermediate values. Each callee-saved register used costs 8 bytes in the prologue
(save) and 8 bytes in the epilogue (restore). For values with very short live ranges
used only once immediately after definition, this cost exceeds the benefit.

Example: For `int a + int b`, the compiler generates 4-6 intermediate cast/binop
values. Each gets a callee-saved register, exhausting all 5 registers (rbx, r12-r15)
even for trivial functions. This creates 176-byte frames where GCC uses 32 bytes.

Impact: PostgreSQL's plpgsql recursion test fails because stack frames are 4x larger
than expected, hitting the stack depth limit 4x sooner.

Fix: Add a minimum benefit threshold to the register allocator:
- Only allocate a callee-saved register when the value's live range and use count
  justify the fixed 8-byte save/restore cost per register.
- Values used only once right after definition get no benefit from a register
  (codegen already uses rax/t0 for computation, so the register is just a
  redundant copy destination).
- Heuristic: require at least N uses or a live range spanning N instructions
  before assigning a callee-saved register, where N accounts for the save/restore
  overhead amortization.

This is complementary to (not conflicting with) the integer_narrowing_optimization
task, which eliminates unnecessary I32->I64->I32 cast chains at the IR level.

Files to modify:
- src/backend/regalloc.rs (add cost-benefit filter to candidate selection)
