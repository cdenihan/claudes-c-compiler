Codegen Compare-Branch Fusion Optimization

Goal: Fuse Cmp + CondBranch patterns at code generation time to eliminate
materialization of boolean comparison results when the Cmp is only used
by an immediately-following CondBranch terminator.

Current codegen for (i < n) ? goto A : goto B:
  cmpq %rcx, %rax
  setl %al
  movzbq %al, %rax
  movq %rax, -offset(%rbp)   # store bool to stack
  movq -offset(%rbp), %rax   # load bool from stack
  testq %rax, %rax
  jne .Ltrue
  jmp .Lfalse

Optimized:
  cmpq %rcx, %rax
  jl .Ltrue
  jmp .Lfalse

This is ~7 instructions -> ~3 instructions in every conditional branch,
which is extremely hot in loops (e.g., zlib's deflate_slow takes 48% of
execution time, and its inner loop has multiple comparisons).

Implementation plan:
1. In generate_instruction/generate_terminator (generation.rs), detect when
   the last instruction in a block is a Cmp and the terminator is a CondBranch
   that uses the Cmp's result.
2. When detected, skip normal Cmp codegen and instead emit a fused
   compare-and-branch sequence directly.
3. Apply this for all three backends (x86, ARM, RISC-V) via the ArchCodegen trait.

Expected impact: ~2-3x improvement in tight loop performance.
Affects: x86, ARM, RISC-V backends.
