Fix F128 (long double) load/store on ARM and RISC-V backends

Problem:
- On ARM and RISC-V, long double is 128-bit IEEE quad precision (16 bytes)
- The current codegen only loads/stores 8 bytes (falls through to the 64-bit default)
- This causes all long double loads from globals/statics to return 0 or garbage
- Multiple test failures: compiler_suite_0169_0019, compiler_suite_0031_0118, etc.

Fix:
- Override emit_load and emit_store for F128 on both ARM and RISC-V
- Track F128 values with full precision in their 16-byte stack slots
- For loads: load 16 bytes into slot, call __trunctfdf2 to get f64 approx in accumulator
- For stores: if full precision available, copy 16 bytes; else call __extenddftf2
- Also fix emit_load_with_const_offset for F128

Status: in_progress
