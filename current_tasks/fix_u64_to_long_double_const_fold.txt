Task: Fix uint64-to-long-double constant folding precision loss
Status: in_progress
Started: 2026-01-27

Problem: When constant-folding a uint64 to long double (x87 80-bit) conversion,
several code paths incorrectly convert through f64 (64-bit double) first, losing
precision. Since f64 has only 53-bit mantissa but x87 has 64-bit mantissa, large
uint64 values like ULLONG_MAX (2^64-1) get rounded to 2^64.

The correct conversion functions (long_double_from_u64/i64) exist and are already
used in constant_fold.rs and simplify.rs::fold_int_cast(), but not in:
1. sema/const_eval.rs bits_to_irconst() - LongDouble case
2. sema/const_eval.rs cast_i128_to_ctype() - LongDouble case
3. ir/lowering/const_eval.rs cast_i128_to_ir_type() - F128 case
4. simplify.rs fold_i128_cast() - F128 case

Impact: Fixes compiler_suite_0137_0508 test failure and potentially other
precision-sensitive long double operations.

Files to change:
- src/frontend/sema/const_eval.rs
- src/ir/lowering/const_eval.rs
- src/passes/simplify.rs
