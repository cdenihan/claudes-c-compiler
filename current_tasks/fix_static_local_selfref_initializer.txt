Fix: static local variable self-referential member address initializers

Bug: When a function-scope static variable has an initializer that references
the address of one of its own members (e.g., &local_var.entry), the address
is emitted as zero instead of the correct symbol+offset. File-scope statics
work correctly because GlobalInfo is registered before init evaluation.

Root cause: In lower_local_static_decl (stmt.rs), the GlobalInfo for the
static local was inserted into self.globals AFTER the initializer was evaluated.
When the initializer contains &(local_var).member, resolve_chained_member_access
needs self.globals to look up the struct layout for computing field offsets.

Fix: Move self.globals.insert() to before the initializer evaluation, matching
the pattern already used in lower_global_decl (global_decl.rs).

This fixes kernel/reboot.c which uses DECLARE_WORK inside ctrl_alt_del(),
creating a static local with list_head self-pointers.
