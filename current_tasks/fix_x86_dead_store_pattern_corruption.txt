Fix x86 peephole dead store elimination pattern_bytes corruption

The dead store elimination pass in the x86 peephole optimizer had a bug where
the pattern_bytes buffer was corrupted by the sub-byte-offset check loop for
multi-byte (Q/8-byte) stores. The loop wrote sub-offsets (store_offset+1 through
store_offset+7) into pattern_bytes, but subsequent scans within the same store's
forward window would skip re-writing the original pattern (guarded by
"if pattern_len == 0") and use the stale sub-offset pattern instead.

This caused incorrect elimination of stores when:
1. A Q store to offset X existed
2. An Other/Cmp instruction with no rbp_offset set (e.g., movl %eax, %eax or
   cmpl -X(%rbp), %eax after memory_fold) was scanned first, triggering the
   sub-byte check loop which corrupted pattern_bytes
3. A later instruction that actually read offset X (e.g., a memory-folded cmpl)
   was checked against the wrong pattern (X+7 instead of X)
4. A subsequent store to X was found, incorrectly marking the original as dead

Fix: use a separate sub_pattern_bytes buffer for the sub-byte-offset checks
to avoid corrupting the main pattern_bytes buffer.

Manifested as 4 failing tests in oniguruma's testcu (UTF-16 BE regex tests)
where the comparison `to + 1 >= data[x*2]` in add_code_range_to_buf() was
miscompiled, causing incorrect character class range merging.

Verification:
- Test suite: x86 2989/2990 (100.0%), ARM 2861/2868 (99.8%), RISC-V 2854/2859 (99.8%), i686 2730/2737 (99.7%)
- Projects: 47/48 passed (only mbedtls/riscv failed, pre-existing)
- All 12 core projects pass on all 4 architectures
- oniguruma: 4565 tests pass on x86, 0 failures (previously 4 failures)

Status: done
