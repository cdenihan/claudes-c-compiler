Bug: Storage class specifiers (extern, static) inside typeof's statement
expression leak into the outer declaration.

Example: typeof(({ extern void bar(void); x; })) y = x;
The 'extern' from 'bar' leaks into the declaration of 'y', causing y to be
treated as a global/external symbol instead of a local variable.

Root cause: parse_typeof_specifier() in src/frontend/parser/types.rs does not
save/restore self.attrs around its inner parsing. When the typeof expression
is a statement expression containing declarations with storage class specifiers
(extern, static, etc.), those specifiers leak into self.attrs and affect the
outer declaration.

Impact: Causes 106+ undefined reference errors when building the Linux kernel,
as kernel macros like hlist_for_each_entry_rcu use typeof(READ_ONCE(x)) which
expands to typeof(({ compiletime_assert(...); expr; })), and the compiletime_assert
macro (under __OPTIMIZE__) generates extern function declarations inside the
statement expression.

Status: in_progress
