Fix unsigned sub-int type constant folding in sema const eval
==============================================================

Problem: (unsigned short)(-1) << 1 evaluates to -2 instead of 131070.

Root cause: sema's bits_to_irconst stores (unsigned short)(-1) as IrConst::I16(-1).
When this cached value is later used in binary op evaluation, to_i64() sign-extends
to -1 (full 64-bit), so the shift computes (-1) << 1 = -2 instead of 65535 << 1 = 131070.

The IrConst enum lacks unsigned sub-int variants (U8, U16), so unsigned short/char
values get sign-truncated into I8/I16, losing their unsigned nature.

Fix approach: In sema's bits_to_irconst, for unsigned sub-int types (UShort, UChar),
store the value as IrConst::I32 (with the zero-extended value) since C integer promotion
would promote these to int anyway. This matches what IR lowering's const_eval already does
(line 115-117 of ir/lowering/const_eval.rs uses I64 for U8/U16).

This is a cross-architecture fix affecting all 3 backends (x86, ARM, RISC-V) since it's
in the frontend/sema layer.

Test: tcc_55_lshift_type fails on all 3 architectures with this bug.
