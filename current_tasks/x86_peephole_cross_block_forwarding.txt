Task: Extend x86 peephole store forwarding across basic block boundaries

Problem: The current store-forwarding optimization (Pattern 8) stops at labels
and jumps, treating them as absolute barriers. This means values stored before
a label or conditional branch cannot be forwarded to loads after them.

In tight loops like zlib's slide_hash, the loop body spans multiple basic blocks
(loop header, condition, body, latch). The inner loop has patterns like:
  movq %rax, -0x90(%rbp)    # store to stack at end of block
  ...label...
  movq -0x90(%rbp), %rax    # reload same value at start of next block

These are extremely common in the stack-based codegen model. The peephole
currently can't optimize them because labels are barriers.

Solution: Implement cross-block store forwarding that tracks register-to-slot
mappings across fallthrough edges and within loop bodies. Key insight: if all
predecessors of a block store the same register to the same slot, the load
at the top of the block is redundant.

Specifically:
1. Track active store mappings (slot -> register) across the entire function
2. At labels, preserve mappings where the value was stored on all incoming paths
3. At unconditional jumps/fallthrough, propagate mappings forward
4. At conditional branches, be conservative but allow fallthrough propagation

This directly addresses the #1 bottleneck in loop-heavy benchmarks like zlib.

Scope: x86 peephole optimizer only (peephole.rs)
