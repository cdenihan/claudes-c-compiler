Task: Fix shift operator type semantics and unsigned int-float conversions

Problems identified:
1. Shift operators (<<, >>) use common_type(lhs, rhs) to determine the operation type.
   Per C standard, shifts should use the promoted type of the LEFT operand only.
   The right operand is independently promoted. This causes:
   - Wrong signedness for shifts (AShr instead of LShr for unsigned left operands)
   - Wrong truncation (no truncation when left is 32-bit but right is 64-bit)

2. Unsigned-to-float cast uses scvtf (signed convert) instead of ucvtf on ARM.
   Similarly, float-to-unsigned uses fcvtzs (signed) instead of fcvtzu.
   Same issue exists on x86 (cvtsi2sd instead of proper unsigned handling)
   and RISC-V.

3. The infer_expr_type for BinaryOp also returns common_type for shifts,
   which should instead return the promoted left operand type.

Fix plan:
- In lower_arithmetic_binop: detect shift operators and use left operand's
  promoted type for result, signedness, and truncation
- In infer_expr_type: same fix for shift operators
- In all 3 backends: add unsigned conversion paths for casts

Status: IN PROGRESS
